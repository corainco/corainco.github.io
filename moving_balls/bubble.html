<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E10: Sparkling Water Bubbles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #001a33, #003366);
        }
        canvas {
            display: block;
            box-shadow: 0 0 30px rgba(0, 100, 200, 0.5);
        }
    </style>
</head>
<body>
    <script>
        // Bubble class to manage individual bubble behavior
        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // Randomized size for variation
                this.r = random(4, 20);
                // Smaller bubbles rise faster (more realistic)
                this.vy = map(this.r, 4, 20, -2.5, -0.8);
                // Horizontal drift for natural movement
                this.vx = random(-0.3, 0.3);
                // Color with slight variation and transparency
                this.alpha = random(150, 200);
                this.hue = random(180, 220);
                // Wobble parameters using Perlin noise
                this.noiseOffsetX = random(1000);
                this.noiseOffsetY = random(1000);
                this.wobbleSpeed = random(0.01, 0.03);
                // Shimmer effect
                this.shimmer = random(TWO_PI);
            }

            update() {
                // Apply velocity
                this.y += this.vy;
                this.x += this.vx;

                // Add subtle wobble using Perlin noise
                let wobbleX = map(noise(this.noiseOffsetX), 0, 1, -0.5, 0.5);
                let wobbleY = map(noise(this.noiseOffsetY), 0, 1, -0.2, 0.2);
                this.x += wobbleX;
                this.y += wobbleY;

                // Increment noise offsets
                this.noiseOffsetX += this.wobbleSpeed;
                this.noiseOffsetY += this.wobbleSpeed;

                // Update shimmer
                this.shimmer += 0.05;

                // Bounce off left and right walls
                if (this.x - this.r < 0) {
                    this.x = this.r;
                    this.vx *= -0.8;
                } else if (this.x + this.r > width) {
                    this.x = width - this.r;
                    this.vx *= -0.8;
                }

                // Pop and respawn at bottom when reaching top
                if (this.y + this.r < 0) {
                    this.respawn();
                }
            }

            respawn() {
                // Respawn at bottom with new properties
                this.x = random(50, width - 50);
                this.y = height + this.r;
                this.r = random(4, 20);
                this.vy = map(this.r, 4, 20, -2.5, -0.8);
                this.vx = random(-0.3, 0.3);
                this.alpha = random(150, 200);
                this.hue = random(180, 220);
            }

            draw() {
                push();
                
                // Outer glow
                let glowAlpha = map(sin(this.shimmer), -1, 1, 10, 30);
                noStroke();
                fill(this.hue, 80, 100, glowAlpha);
                circle(this.x, this.y, this.r * 2.5);

                // Main bubble body
                fill(this.hue, 60, 95, this.alpha);
                stroke(this.hue, 80, 100, this.alpha + 30);
                strokeWeight(1);
                circle(this.x, this.y, this.r * 2);

                // Highlight for dimension
                noStroke();
                fill(200, 10, 100, this.alpha * 0.6);
                let highlightOffset = this.r * 0.3;
                circle(this.x - highlightOffset, this.y - highlightOffset, this.r * 0.6);

                pop();
            }

            // Check if bubble is clicked
            isClicked(mx, my) {
                let d = dist(mx, my, this.x, this.y);
                return d < this.r;
            }
        }

        // Array to hold all bubbles
        let bubbles = [];
        let isPaused = false;
        const INITIAL_BUBBLE_COUNT = 15;

        function setup() {
            createCanvas(600, 800);
            colorMode(HSB, 360, 100, 100, 255);
            
            // Create initial bubbles
            for (let i = 0; i < INITIAL_BUBBLE_COUNT; i++) {
                let x = random(50, width - 50);
                let y = random(height * 0.3, height);
                bubbles.push(new Bubble(x, y));
            }
        }

        function draw() {
            // Create sparkling water gradient background
            drawBackground();

            if (!isPaused) {
                // Update and draw each bubble
                for (let bubble of bubbles) {
                    bubble.update();
                    bubble.draw();
                }
            } else {
                // Just draw when paused
                for (let bubble of bubbles) {
                    bubble.draw();
                }
            }

            // Draw subtle bottom source area
            drawBottomGlow();

            // Display controls
            displayControls();
        }

        function drawBackground() {
            // Animated gradient for water depth effect
            let topColor = color(200, 30, 15);
            let bottomColor = color(190, 50, 30);
            
            for (let y = 0; y < height; y++) {
                let inter = map(y, 0, height, 0, 1);
                let c = lerpColor(topColor, bottomColor, inter);
                stroke(c);
                line(0, y, width, y);
            }
        }

        function drawBottomGlow() {
            // Subtle glow at bottom where bubbles originate
            push();
            noStroke();
            let glowColor = color(190, 60, 40, 20);
            fill(glowColor);
            ellipse(width / 2, height, width * 1.2, 80);
            pop();
        }

        function displayControls() {
            push();
            fill(0, 0, 100, 200);
            noStroke();
            textSize(12);
            textAlign(LEFT);
            text("Click: Add bubble | Space: Pause | Bubbles: " + bubbles.length, 10, 20);
            if (isPaused) {
                textAlign(CENTER);
                textSize(24);
                text("PAUSED", width / 2, height / 2);
            }
            pop();
        }

        function mousePressed() {
            // Add a new bubble at mouse position
            bubbles.push(new Bubble(mouseX, mouseY));
            
            // Limit total bubbles to prevent performance issues
            if (bubbles.length > 50) {
                bubbles.shift();
            }
        }

        function keyPressed() {
            // Space bar to pause/unpause
            if (key === ' ') {
                isPaused = !isPaused;
            }
            
            // 'R' key to reset
            if (key === 'r' || key === 'R') {
                bubbles = [];
                for (let i = 0; i < INITIAL_BUBBLE_COUNT; i++) {
                    let x = random(50, width - 50);
                    let y = random(height * 0.3, height);
                    bubbles.push(new Bubble(x, y));
                }
            }
        }
    </script>
</body>
</html>